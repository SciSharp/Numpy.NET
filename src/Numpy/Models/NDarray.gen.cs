// Copyright (c) 2020 by Meinrad Recheis (Member of SciSharp)
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Python.Runtime;
using Numpy.Models;
#if PYTHON_INCLUDED
using Python.Included;
#endif

namespace Numpy
{
    public partial class NDarray
    {
        
        /// <summary>
        ///	Copy an element of an array to a standard Python scalar and return it.<br></br>
        ///	
        ///	Notes
        ///	
        ///	When the data type of a is longdouble or clongdouble, item() returns
        ///	a scalar array object because there is no available Python scalar that
        ///	would not lose information.<br></br>
        ///	 Void arrays return a buffer object for item(),
        ///	unless fields are defined, in which case a tuple is returned.<br></br>
        ///	
        ///	item is very similar to a[args], except, instead of an array scalar,
        ///	a standard Python scalar is returned.<br></br>
        ///	 This can be useful for speeding up
        ///	access to elements of the array and doing arithmetic on elements of the
        ///	array using Python’s optimized math.
        /// </summary>
        /// <returns>
        ///	A copy of the specified element of the array as a suitable
        ///	Python scalar
        /// </returns>
        public T item<T>(params int[] args)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                args,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("item", pyargs, kwargs);
            return ToCsharp<T>(py);
        }
        
        /*
        /// <summary>
        ///	Return the array as a (possibly nested) list.<br></br>
        ///	
        ///	Return a copy of the array data as a (nested) Python list.<br></br>
        ///	
        ///	Data items are converted to the nearest compatible Python type.<br></br>
        ///	
        ///	Notes
        ///	
        ///	The array may be recreated, a = np.array(a.tolist()).
        /// </summary>
        /// <returns>
        ///	The possibly nested list of array elements.
        /// </returns>
        public List<T> tolist<T>()
        {
            //auto-generated code, do not change
            var __self__=self;
            dynamic py = __self__.InvokeMethod("tolist");
            return ToCsharp<List<T>>(py);
        }
        */
        
        /// <summary>
        ///	Write array to a file as text or binary (default).<br></br>
        ///	
        ///	Data is always written in ‘C’ order, independent of the order of a.<br></br>
        ///	
        ///	The data produced by this method can be recovered using the function
        ///	fromfile().<br></br>
        ///	
        ///	Notes
        ///	
        ///	This is a convenience function for quick storage of array data.<br></br>
        ///	
        ///	Information on endianness and precision is lost, so this method is not a
        ///	good choice for files intended to archive data or transport data between
        ///	machines with different endianness.<br></br>
        ///	 Some of these problems can be overcome
        ///	by outputting the data as text files, at the expense of speed and file
        ///	size.<br></br>
        ///	
        ///	When fid is a file object, array contents are directly written to the
        ///	file, bypassing the file object’s write method.<br></br>
        ///	 As a result, tofile
        ///	cannot be used with files objects supporting compression (e.g., GzipFile)
        ///	or file-like objects that do not support fileno() (e.g., BytesIO).
        /// </summary>
        /// <param name="fid">
        ///	An open file object, or a string containing a filename.
        /// </param>
        /// <param name="sep">
        ///	Separator between array items for text output.<br></br>
        ///	
        ///	If “” (empty), a binary file is written, equivalent to
        ///	file.write(a.tobytes()).
        /// </param>
        /// <param name="format">
        ///	Format string for text file output.<br></br>
        ///	
        ///	Each entry in the array is formatted to text by first converting
        ///	it to the closest Python type, and then using “format” % item.
        /// </param>
        public void tofile(string fid, string sep, string format)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                fid,
                sep,
                format,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("tofile", pyargs, kwargs);
        }
        
        /// <summary>
        ///	Dump a pickle of the array to the specified file.<br></br>
        ///	
        ///	The array can be read back with pickle.load or numpy.load.
        /// </summary>
        /// <param name="file">
        ///	A string naming the dump file.
        /// </param>
        public void dump(string file)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                file,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("dump", pyargs, kwargs);
        }
        
        /// <summary>
        ///	Returns the pickle of the array as a string.<br></br>
        ///	
        ///	pickle.loads or numpy.loads will convert the string back to an array.
        /// </summary>
        public void dumps()
        {
            //auto-generated code, do not change
            var __self__=self;
            dynamic py = __self__.InvokeMethod("dumps");
        }
        
        /// <summary>
        ///	Copy of the array, cast to a specified type.<br></br>
        ///	
        ///	Notes
        ///	
        ///	Starting in NumPy 1.9, astype method now returns an error if the string
        ///	dtype to cast to is not long enough in ‘safe’ casting mode to hold the max
        ///	value of integer/float array that is being casted.<br></br>
        ///	 Previously the casting
        ///	was allowed even if the result was truncated.
        /// </summary>
        /// <param name="dtype">
        ///	Typecode or data-type to which the array is cast.
        /// </param>
        /// <param name="order">
        ///	Controls the memory layout order of the result.<br></br>
        ///	
        ///	‘C’ means C order, ‘F’ means Fortran order, ‘A’
        ///	means ‘F’ order if all the arrays are Fortran contiguous,
        ///	‘C’ order otherwise, and ‘K’ means as close to the
        ///	order the array elements appear in memory as possible.<br></br>
        ///	
        ///	Default is ‘K’.
        /// </param>
        /// <param name="casting">
        ///	Controls what kind of data casting may occur.<br></br>
        ///	Defaults to ‘unsafe’
        ///	for backwards compatibility.
        /// </param>
        /// <param name="subok">
        ///	If True, then sub-classes will be passed-through (default), otherwise
        ///	the returned array will be forced to be a base-class array.
        /// </param>
        /// <param name="copy">
        ///	By default, astype always returns a newly allocated array.<br></br>
        ///	If this
        ///	is set to false, and the dtype, order, and subok
        ///	requirements are satisfied, the input array is returned instead
        ///	of a copy.
        /// </param>
        /// <returns>
        ///	Unless copy is False and the other conditions for returning the input
        ///	array are satisfied (see description for copy input parameter), arr_t
        ///	is a new array of the same shape as the input array, with dtype, order
        ///	given by dtype, order.
        /// </returns>
        public NDarray astype(Dtype dtype, string order = null, string casting = null, bool? subok = null, bool? copy = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                dtype,
            });
            var kwargs=new PyDict();
            if (order!=null) kwargs["order"]=ToPython(order);
            if (casting!=null) kwargs["casting"]=ToPython(casting);
            if (subok!=null) kwargs["subok"]=ToPython(subok);
            if (copy!=null) kwargs["copy"]=ToPython(copy);
            dynamic py = __self__.InvokeMethod("astype", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        ///	Swap the bytes of the array elements
        ///	
        ///	Toggle between low-endian and big-endian data representation by
        ///	returning a byteswapped array, optionally swapped in-place.
        /// </summary>
        /// <param name="inplace">
        ///	If True, swap bytes in-place, default is False.
        /// </param>
        /// <returns>
        ///	The byteswapped array.<br></br>
        ///	 If inplace is True, this is
        ///	a view to self.
        /// </returns>
        public NDarray byteswap(bool? inplace = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (inplace!=null) kwargs["inplace"]=ToPython(inplace);
            dynamic py = __self__.InvokeMethod("byteswap", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        ///	Return a copy of the array.
        /// </summary>
        /// <param name="order">
        ///	Controls the memory layout of the copy.<br></br>
        ///	‘C’ means C-order,
        ///	‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous,
        ///	‘C’ otherwise.<br></br>
        ///	‘K’ means match the layout of a as closely
        ///	as possible.<br></br>
        ///	(Note that this function and numpy.copy are very
        ///	similar, but have different default values for their order=
        ///	arguments.)
        /// </param>
        public NDarray copy(string order = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (order!=null) kwargs["order"]=ToPython(order);
            dynamic py = __self__.InvokeMethod("copy", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        ///	Returns a field of the given array as a certain type.<br></br>
        ///	
        ///	A field is a view of the array data with a given data-type.<br></br>
        ///	 The values in
        ///	the view are determined by the given type and the offset into the current
        ///	array in bytes.<br></br>
        ///	 The offset needs to be such that the view dtype fits in the
        ///	array dtype; for example an array of dtype complex128 has 16-byte elements.<br></br>
        ///	
        ///	If taking a view with a 32-bit integer (4 bytes), the offset needs to be
        ///	between 0 and 12 bytes.
        /// </summary>
        /// <param name="dtype">
        ///	The data type of the view.<br></br>
        ///	The dtype size of the view can not be larger
        ///	than that of the array itself.
        /// </param>
        /// <param name="offset">
        ///	Number of bytes to skip before beginning the element view.
        /// </param>
        public void getfield(Dtype dtype, int offset)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                dtype,
                offset,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("getfield", pyargs, kwargs);
        }
        
        /// <summary>
        ///	Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),
        ///	respectively.<br></br>
        ///	
        ///	These Boolean-valued flags affect how numpy interprets the memory
        ///	area used by a (see Notes below).<br></br>
        ///	 The ALIGNED flag can only
        ///	be set to True if the data is actually aligned according to the type.<br></br>
        ///	
        ///	The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set
        ///	to True.<br></br>
        ///	 The flag WRITEABLE can only be set to True if the array owns its
        ///	own memory, or the ultimate owner of the memory exposes a writeable buffer
        ///	interface, or is a string.<br></br>
        ///	 (The exception for string is made so that
        ///	unpickling can be done without copying memory.)
        ///	
        ///	Notes
        ///	
        ///	Array flags provide information about how the memory area used
        ///	for the array is to be interpreted.<br></br>
        ///	 There are 7 Boolean flags
        ///	in use, only four of which can be changed by the user:
        ///	WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.<br></br>
        ///	
        ///	WRITEABLE (W) the data area can be written to;
        ///	
        ///	ALIGNED (A) the data and strides are aligned appropriately for the hardware
        ///	(as determined by the compiler);
        ///	
        ///	UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;
        ///	
        ///	WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
        ///	by .base).<br></br>
        ///	 When the C-API function PyArray_ResolveWritebackIfCopy is
        ///	called, the base array will be updated with the contents of this array.<br></br>
        ///	
        ///	All flags can be accessed using the single (upper case) letter as well
        ///	as the full name.
        /// </summary>
        /// <param name="write">
        ///	Describes whether or not a can be written to.
        /// </param>
        /// <param name="align">
        ///	Describes whether or not a is aligned properly for its type.
        /// </param>
        /// <param name="uic">
        ///	Describes whether or not a is a copy of another “base” array.
        /// </param>
        public void setflags(bool? write = null, bool? align = null, bool? uic = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (write!=null) kwargs["write"]=ToPython(write);
            if (align!=null) kwargs["align"]=ToPython(align);
            if (uic!=null) kwargs["uic"]=ToPython(uic);
            dynamic py = __self__.InvokeMethod("setflags", pyargs, kwargs);
        }
        
        /// <summary>
        ///	Fill the array with a scalar value.
        /// </summary>
        /// <param name="value">
        ///	All elements of a will be assigned this value.
        /// </param>
        public void fill(ValueType @value)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                @value,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("fill", pyargs, kwargs);
        }
        
        /// <summary>
        ///	Return a copy of the array collapsed into one dimension.
        /// </summary>
        /// <param name="order">
        ///	‘C’ means to flatten in row-major (C-style) order.<br></br>
        ///	
        ///	‘F’ means to flatten in column-major (Fortran-
        ///	style) order.<br></br>
        ///	‘A’ means to flatten in column-major
        ///	order if a is Fortran contiguous in memory,
        ///	row-major order otherwise.<br></br>
        ///	‘K’ means to flatten
        ///	a in the order the elements occur in memory.<br></br>
        ///	
        ///	The default is ‘C’.
        /// </param>
        /// <returns>
        ///	A copy of the input array, flattened to one dimension.
        /// </returns>
        public NDarray flatten(string order = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (order!=null) kwargs["order"]=ToPython(order);
            dynamic py = __self__.InvokeMethod("flatten", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        ///	For unpickling.<br></br>
        ///	
        ///	The state argument must be a sequence that contains the following
        ///	elements:
        /// </summary>
        /// <param name="version">
        ///	optional pickle version.<br></br>
        ///	If omitted defaults to 0.
        /// </param>
        /// <param name="rawdata">
        ///	a binary string with the data (or a list if ‘a’ is an object array)
        /// </param>
        public void __setstate__(int version, Shape shape, Dtype dtype, bool isFortran, string rawdata)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                version,
                shape,
                dtype,
                isFortran,
                rawdata,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("__setstate__", pyargs, kwargs);
        }
        
    }
}
