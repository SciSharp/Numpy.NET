// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Runtime.InteropServices;
using System.Text;
using Numpy.Models;

using Microsoft.VisualStudio.TestTools.UnitTesting;
using Assert = NUnit.Framework.Assert;

namespace Numpy.UnitTest
{
    [TestClass]
    public class NumPy_mathTest : BaseTestCase
    {

        [TestMethod]
        public void sinTest()
        {
            // Print sine of one angle:

            // >>> np.sin(np.pi/2.)
            // 1.0
            // 

#if TODO
            var given=  np.sin(np.pi/2.);
            var expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
#endif
            // Print sines of an array of angles given in degrees:

            // >>> np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )
            // array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])
            // 

#if TODO
             given=  np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. );
             expected=
                "array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Plot the sine function:

            // >>> import matplotlib.pylab as plt
            // >>> x = np.linspace(-np.pi, np.pi, 201)
            // >>> plt.plot(x, np.sin(x))
            // >>> plt.xlabel('Angle [rad]')
            // >>> plt.ylabel('sin(x)')
            // >>> plt.axis('tight')
            // >>> plt.show()
            // 

#if TODO
             given=  import matplotlib.pylab as plt;
             given=  x = np.linspace(-np.pi, np.pi, 201);
             given=  plt.plot(x, np.sin(x));
             given=  plt.xlabel('Angle [rad]');
             given=  plt.ylabel('sin(x)');
             given=  plt.axis('tight');
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void cosTest()
        {
            // >>> np.cos(np.array([0, np.pi/2, np.pi]))
            // array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])
            // >>>
            // >>> # Example of providing the optional output parameter
            // >>> out2 = np.cos([0.1], out1)
            // >>> out2 is out1
            // True
            // >>>
            // >>> # Example of ValueError due to provision of shape mis-matched `out`
            // >>> np.cos(np.zeros((3,3)),np.zeros((2,2)))
            // Traceback (most recent call last):
            //   File "<stdin>", line 1, in <module>
            // ValueError: invalid return array shape
            // 

#if TODO
            var given=  np.cos(np.array({0, np.pi/2, np.pi}));
            var expected=
                "array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])";
            Assert.AreEqual(expected, given.repr);
             given= ;
             given=  # Example of providing the optional output parameter;
             given=  out2 = np.cos({0.1}, out1);
             given=  out2 is out1;
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
             given= ;
             given=  # Example of ValueError due to provision of shape mis-matched `out`;
             given=  np.cos(np.zeros((3,3)),np.zeros((2,2)));
             expected=
                "Traceback (most recent call last):\n" +
                "  File "<stdin>", line 1, in <module>\n" +
                "ValueError: invalid return array shape";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void tanTest()
        {
            // >>> from math import pi
            // >>> np.tan(np.array([-pi,pi/2,pi]))
            // array([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])
            // >>>
            // >>> # Example of providing the optional output parameter illustrating
            // >>> # that what is returned is a reference to said parameter
            // >>> out2 = np.cos([0.1], out1)
            // >>> out2 is out1
            // True
            // >>>
            // >>> # Example of ValueError due to provision of shape mis-matched `out`
            // >>> np.cos(np.zeros((3,3)),np.zeros((2,2)))
            // Traceback (most recent call last):
            //   File "<stdin>", line 1, in <module>
            // ValueError: invalid return array shape
            // 

#if TODO
            var given=  from math import pi;
             given=  np.tan(np.array({-pi,pi/2,pi}));
            var expected=
                "array([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])";
            Assert.AreEqual(expected, given.repr);
             given= ;
             given=  # Example of providing the optional output parameter illustrating;
             given=  # that what is returned is a reference to said parameter;
             given=  out2 = np.cos({0.1}, out1);
             given=  out2 is out1;
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
             given= ;
             given=  # Example of ValueError due to provision of shape mis-matched `out`;
             given=  np.cos(np.zeros((3,3)),np.zeros((2,2)));
             expected=
                "Traceback (most recent call last):\n" +
                "  File "<stdin>", line 1, in <module>\n" +
                "ValueError: invalid return array shape";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void arcsinTest()
        {
            // >>> np.arcsin(1)     # pi/2
            // 1.5707963267948966
            // >>> np.arcsin(-1)    # -pi/2
            // -1.5707963267948966
            // >>> np.arcsin(0)
            // 0.0
            // 

#if TODO
            var given=  np.arcsin(1)     # pi/2;
            var expected=
                "1.5707963267948966";
            Assert.AreEqual(expected, given.repr);
             given=  np.arcsin(-1)    # -pi/2;
             expected=
                "-1.5707963267948966";
            Assert.AreEqual(expected, given.repr);
             given=  np.arcsin(0);
             expected=
                "0.0";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void arccosTest()
        {
            // We expect the arccos of 1 to be 0, and of -1 to be pi:

            // >>> np.arccos([1, -1])
            // array([ 0.        ,  3.14159265])
            // 

#if TODO
            var given=  np.arccos({1, -1});
            var expected=
                "array([ 0.        ,  3.14159265])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Plot arccos:

            // >>> import matplotlib.pyplot as plt
            // >>> x = np.linspace(-1, 1, num=100)
            // >>> plt.plot(x, np.arccos(x))
            // >>> plt.axis('tight')
            // >>> plt.show()
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  x = np.linspace(-1, 1, num=100);
             given=  plt.plot(x, np.arccos(x));
             given=  plt.axis('tight');
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void arctanTest()
        {
            // We expect the arctan of 0 to be 0, and of 1 to be pi/4:

            // >>> np.arctan([0, 1])
            // array([ 0.        ,  0.78539816])
            // 

#if TODO
            var given=  np.arctan({0, 1});
            var expected=
                "array([ 0.        ,  0.78539816])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.pi/4
            // 0.78539816339744828
            // 

#if TODO
             given=  np.pi/4;
             expected=
                "0.78539816339744828";
            Assert.AreEqual(expected, given.repr);
#endif
            // Plot arctan:

            // >>> import matplotlib.pyplot as plt
            // >>> x = np.linspace(-10, 10)
            // >>> plt.plot(x, np.arctan(x))
            // >>> plt.axis('tight')
            // >>> plt.show()
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  x = np.linspace(-10, 10);
             given=  plt.plot(x, np.arctan(x));
             given=  plt.axis('tight');
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void hypotTest()
        {
            // >>> np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))
            // array([[ 5.,  5.,  5.],
            //        [ 5.,  5.,  5.],
            //        [ 5.,  5.,  5.]])
            // 

#if TODO
            var given=  np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)));
            var expected=
                "array([[ 5.,  5.,  5.],\n" +
                "       [ 5.,  5.,  5.],\n" +
                "       [ 5.,  5.,  5.]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Example showing broadcast of scalar_like argument:

            // >>> np.hypot(3*np.ones((3, 3)), [4])
            // array([[ 5.,  5.,  5.],
            //        [ 5.,  5.,  5.],
            //        [ 5.,  5.,  5.]])
            // 

#if TODO
             given=  np.hypot(3*np.ones((3, 3)), {4});
             expected=
                "array([[ 5.,  5.,  5.],\n" +
                "       [ 5.,  5.,  5.],\n" +
                "       [ 5.,  5.,  5.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void arctan2Test()
        {
            // Consider four points in different quadrants:

            // >>> x = np.array([-1, +1, +1, -1])
            // >>> y = np.array([-1, -1, +1, +1])
            // >>> np.arctan2(y, x) * 180 / np.pi
            // array([-135.,  -45.,   45.,  135.])
            // 

#if TODO
            var given=  x = np.array({-1, +1, +1, -1});
             given=  y = np.array({-1, -1, +1, +1});
             given=  np.arctan2(y, x) * 180 / np.pi;
            var expected=
                "array([-135.,  -45.,   45.,  135.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Note the order of the parameters. arctan2 is defined also when x2 = 0
            // and at several other special points, obtaining values in
            // the range [-pi, pi]:

            // >>> np.arctan2([1., -1.], [0., 0.])
            // array([ 1.57079633, -1.57079633])
            // >>> np.arctan2([0., 0., np.inf], [+0., -0., np.inf])
            // array([ 0.        ,  3.14159265,  0.78539816])
            // 

#if TODO
             given=  np.arctan2({1., -1.}, {0., 0.});
             expected=
                "array([ 1.57079633, -1.57079633])";
            Assert.AreEqual(expected, given.repr);
             given=  np.arctan2({0., 0., np.inf}, {+0., -0., np.inf});
             expected=
                "array([ 0.        ,  3.14159265,  0.78539816])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void degreesTest()
        {
            // Convert a radian array to degrees

            // >>> rad = np.arange(12.)*np.pi/6
            // >>> np.degrees(rad)
            // array([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,
            //         270.,  300.,  330.])
            // 

#if TODO
            var given=  rad = np.arange(12.)*np.pi/6;
             given=  np.degrees(rad);
            var expected=
                "array([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,\n" +
                "        270.,  300.,  330.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> out = np.zeros((rad.shape))
            // >>> r = degrees(rad, out)
            // >>> np.all(r == out)
            // True
            // 

#if TODO
             given=  out = np.zeros((rad.shape));
             given=  r = degrees(rad, out);
             given=  np.all(r == out);
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void radiansTest()
        {
            // Convert a degree array to radians

            // >>> deg = np.arange(12.) * 30.
            // >>> np.radians(deg)
            // array([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,
            //         2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,
            //         5.23598776,  5.75958653])
            // 

#if TODO
            var given=  deg = np.arange(12.) * 30.;
             given=  np.radians(deg);
            var expected=
                "array([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,\n" +
                "        2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,\n" +
                "        5.23598776,  5.75958653])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> out = np.zeros((deg.shape))
            // >>> ret = np.radians(deg, out)
            // >>> ret is out
            // True
            // 

#if TODO
             given=  out = np.zeros((deg.shape));
             given=  ret = np.radians(deg, out);
             given=  ret is out;
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void unwrapTest()
        {
            // >>> phase = np.linspace(0, np.pi, num=5)
            // >>> phase[3:] += np.pi
            // >>> phase
            // array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531])
            // >>> np.unwrap(phase)
            // array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ])
            // 

#if TODO
            var given=  phase = np.linspace(0, np.pi, num=5);
             given=  phase{3:} += np.pi;
             given=  phase;
            var expected=
                "array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531])";
            Assert.AreEqual(expected, given.repr);
             given=  np.unwrap(phase);
             expected=
                "array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void deg2radTest()
        {
            // >>> np.deg2rad(180)
            // 3.1415926535897931
            // 

#if TODO
            var given=  np.deg2rad(180);
            var expected=
                "3.1415926535897931";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void rad2degTest()
        {
            // >>> np.rad2deg(np.pi/2)
            // 90.0
            // 

#if TODO
            var given=  np.rad2deg(np.pi/2);
            var expected=
                "90.0";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void sinhTest()
        {
            // >>> np.sinh(0)
            // 0.0
            // >>> np.sinh(np.pi*1j/2)
            // 1j
            // >>> np.sinh(np.pi*1j) # (exact value is 0)
            // 1.2246063538223773e-016j
            // >>> # Discrepancy due to vagaries of floating point arithmetic.
            // 

#if TODO
            var given=  np.sinh(0);
            var expected=
                "0.0";
            Assert.AreEqual(expected, given.repr);
             given=  np.sinh(np.pi*1j/2);
             expected=
                "1j";
            Assert.AreEqual(expected, given.repr);
             given=  np.sinh(np.pi*1j) # (exact value is 0);
             expected=
                "1.2246063538223773e-016j";
            Assert.AreEqual(expected, given.repr);
             given=  # Discrepancy due to vagaries of floating point arithmetic.;
#endif
            // >>> # Example of providing the optional output parameter
            // >>> out2 = np.sinh([0.1], out1)
            // >>> out2 is out1
            // True
            // 

#if TODO
             given=  # Example of providing the optional output parameter;
             given=  out2 = np.sinh({0.1}, out1);
             given=  out2 is out1;
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> # Example of ValueError due to provision of shape mis-matched `out`
            // >>> np.sinh(np.zeros((3,3)),np.zeros((2,2)))
            // Traceback (most recent call last):
            //   File "<stdin>", line 1, in <module>
            // ValueError: invalid return array shape
            // 

#if TODO
             given=  # Example of ValueError due to provision of shape mis-matched `out`;
             given=  np.sinh(np.zeros((3,3)),np.zeros((2,2)));
             expected=
                "Traceback (most recent call last):\n" +
                "  File "<stdin>", line 1, in <module>\n" +
                "ValueError: invalid return array shape";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void coshTest()
        {
            // >>> np.cosh(0)
            // 1.0
            // 

#if TODO
            var given=  np.cosh(0);
            var expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
#endif
            // The hyperbolic cosine describes the shape of a hanging cable:

            // >>> import matplotlib.pyplot as plt
            // >>> x = np.linspace(-4, 4, 1000)
            // >>> plt.plot(x, np.cosh(x))
            // >>> plt.show()
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  x = np.linspace(-4, 4, 1000);
             given=  plt.plot(x, np.cosh(x));
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void tanhTest()
        {
            // >>> np.tanh((0, np.pi*1j, np.pi*1j/2))
            // array([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])
            // 

#if TODO
            var given=  np.tanh((0, np.pi*1j, np.pi*1j/2));
            var expected=
                "array([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> # Example of providing the optional output parameter illustrating
            // >>> # that what is returned is a reference to said parameter
            // >>> out2 = np.tanh([0.1], out1)
            // >>> out2 is out1
            // True
            // 

#if TODO
             given=  # Example of providing the optional output parameter illustrating;
             given=  # that what is returned is a reference to said parameter;
             given=  out2 = np.tanh({0.1}, out1);
             given=  out2 is out1;
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> # Example of ValueError due to provision of shape mis-matched `out`
            // >>> np.tanh(np.zeros((3,3)),np.zeros((2,2)))
            // Traceback (most recent call last):
            //   File "<stdin>", line 1, in <module>
            // ValueError: invalid return array shape
            // 

#if TODO
             given=  # Example of ValueError due to provision of shape mis-matched `out`;
             given=  np.tanh(np.zeros((3,3)),np.zeros((2,2)));
             expected=
                "Traceback (most recent call last):\n" +
                "  File "<stdin>", line 1, in <module>\n" +
                "ValueError: invalid return array shape";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void arcsinhTest()
        {
            // >>> np.arcsinh(np.array([np.e, 10.0]))
            // array([ 1.72538256,  2.99822295])
            // 

#if TODO
            var given=  np.arcsinh(np.array({np.e, 10.0}));
            var expected=
                "array([ 1.72538256,  2.99822295])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void arccoshTest()
        {
            // >>> np.arccosh([np.e, 10.0])
            // array([ 1.65745445,  2.99322285])
            // >>> np.arccosh(1)
            // 0.0
            // 

#if TODO
            var given=  np.arccosh({np.e, 10.0});
            var expected=
                "array([ 1.65745445,  2.99322285])";
            Assert.AreEqual(expected, given.repr);
             given=  np.arccosh(1);
             expected=
                "0.0";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void arctanhTest()
        {
            // >>> np.arctanh([0, -0.5])
            // array([ 0.        , -0.54930614])
            // 

#if TODO
            var given=  np.arctanh({0, -0.5});
            var expected=
                "array([ 0.        , -0.54930614])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void aroundTest()
        {
            // >>> np.around([0.37, 1.64])
            // array([ 0.,  2.])
            // >>> np.around([0.37, 1.64], decimals=1)
            // array([ 0.4,  1.6])
            // >>> np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value
            // array([ 0.,  2.,  2.,  4.,  4.])
            // >>> np.around([1,2,3,11], decimals=1) # ndarray of ints is returned
            // array([ 1,  2,  3, 11])
            // >>> np.around([1,2,3,11], decimals=-1)
            // array([ 0,  0,  0, 10])
            // 

#if TODO
            var given=  np.around({0.37, 1.64});
            var expected=
                "array([ 0.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.around({0.37, 1.64}, decimals=1);
             expected=
                "array([ 0.4,  1.6])";
            Assert.AreEqual(expected, given.repr);
             given=  np.around({.5, 1.5, 2.5, 3.5, 4.5}) # rounds to nearest even value;
             expected=
                "array([ 0.,  2.,  2.,  4.,  4.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.around({1,2,3,11}, decimals=1) # ndarray of ints is returned;
             expected=
                "array([ 1,  2,  3, 11])";
            Assert.AreEqual(expected, given.repr);
             given=  np.around({1,2,3,11}, decimals=-1);
             expected=
                "array([ 0,  0,  0, 10])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void rintTest()
        {
            // >>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
            // >>> np.rint(a)
            // array([-2., -2., -0.,  0.,  2.,  2.,  2.])
            // 

#if TODO
            var given=  a = np.array({-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0});
             given=  np.rint(a);
            var expected=
                "array([-2., -2., -0.,  0.,  2.,  2.,  2.])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void fixTest()
        {
            // >>> np.fix(3.14)
            // 3.0
            // >>> np.fix(3)
            // 3.0
            // >>> np.fix([2.1, 2.9, -2.1, -2.9])
            // array([ 2.,  2., -2., -2.])
            // 

#if TODO
            var given=  np.fix(3.14);
            var expected=
                "3.0";
            Assert.AreEqual(expected, given.repr);
             given=  np.fix(3);
             expected=
                "3.0";
            Assert.AreEqual(expected, given.repr);
             given=  np.fix({2.1, 2.9, -2.1, -2.9});
             expected=
                "array([ 2.,  2., -2., -2.])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void floorTest()
        {
            // >>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
            // >>> np.floor(a)
            // array([-2., -2., -1.,  0.,  1.,  1.,  2.])
            // 

#if TODO
            var given=  a = np.array({-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0});
             given=  np.floor(a);
            var expected=
                "array([-2., -2., -1.,  0.,  1.,  1.,  2.])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void ceilTest()
        {
            // >>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
            // >>> np.ceil(a)
            // array([-1., -1., -0.,  1.,  2.,  2.,  2.])
            // 

#if TODO
            var given=  a = np.array({-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0});
             given=  np.ceil(a);
            var expected=
                "array([-1., -1., -0.,  1.,  2.,  2.,  2.])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void truncTest()
        {
            // >>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
            // >>> np.trunc(a)
            // array([-1., -1., -0.,  0.,  1.,  1.,  2.])
            // 

#if TODO
            var given=  a = np.array({-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0});
             given=  np.trunc(a);
            var expected=
                "array([-1., -1., -0.,  0.,  1.,  1.,  2.])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void prodTest()
        {
            // By default, calculate the product of all elements:

            // >>> np.prod([1.,2.])
            // 2.0

            Assert.AreEqual(2.0, np.prod(new[] { 1.0, 2.0 }).asscalar<double>());

            // Even when the input array is two-dimensional:

            // >>> np.prod([[1.,2.],[3.,4.]])
            // 24.0

            Assert.AreEqual(24.0, (double)np.prod(new[,] { { 1.0, 2.0 }, { 3.0, 4.0 } }));

            // But we can also specify the axis over which to multiply:

            // >>> np.prod([[1.,2.],[3.,4.]], axis=1)
            // array([  2.,  12.])

            var given = np.prod(new[,] { { 1.0, 2.0 }, { 3.0, 4.0 } }, axis: new[] { 1 });
            var expected = "array([ 2., 12.])";
            Assert.AreEqual(expected, given.repr);

            // If the type of x is unsigned, then the output type is
            // the unsigned platform integer:

            // >>> x = np.array([1, 2, 3], dtype=np.uint8)
            // >>> np.prod(x).dtype == np.uint
            // True

            var x = np.array(new byte[] { 1, 2, 3 }, dtype: np.uint8);
            Assert.AreEqual(np.@uint, np.prod(x).dtype);

            // If x is of a signed integer type, then the output type
            // is the default platform integer:

            x = np.array(new byte[] { 1, 2, 3 }, dtype: np.int8);
            Assert.AreEqual(np.int_, np.prod(x).dtype);

            // You can also start the product with a value other than one:

            // >>> np.prod([1, 2], initial=5)
            // 10

            Assert.AreEqual(10, (int)np.prod(new[] { 1, 2 }, initial: 5));
        }


        [TestMethod]
        public void sumTest()
        {
            // >>> np.sum([0.5, 1.5])
            // 2.0
            // >>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)
            // 1
            // >>> np.sum([[0, 1], [0, 5]])
            // 6
            // >>> np.sum([[0, 1], [0, 5]], axis=0)
            // array([0, 6])
            // >>> np.sum([[0, 1], [0, 5]], axis=1)
            // array([1, 5])
            // 

            var given = np.sum(new[] { 0.5, 1.5 });
            var expected =
                "2.0";
            Assert.AreEqual(expected, given.repr);
            given = np.sum(new[] { 0.5, 0.7, 0.2, 1.5 }, dtype: np.int32);
            expected =
               "1";
            Assert.AreEqual(expected, given.repr);
            given = np.sum(new[,] { { 0, 1 }, { 0, 5 } });
            expected =
               "6";
            Assert.AreEqual(expected, given.repr);
            given = np.sum(new[,] { { 0, 1 }, { 0, 5 } }, axis: 0);
            expected =
               "array([0, 6])";
            Assert.AreEqual(expected, given.repr);
            given = np.sum(new[,] { { 0, 1 }, { 0, 5 } }, axis: 1);
            expected =
               "array([1, 5])";
            Assert.AreEqual(expected, given.repr);

            // If the accumulator is too small, overflow occurs:

            // >>> np.ones(128, dtype=np.int8).sum(dtype=np.int8)
            // -128
            // 

#if TODO
             given=  np.ones(128, dtype=np.int8).sum(dtype=np.int8);
             expected=
                "-128";
            Assert.AreEqual(expected, given.repr);
#endif
            // You can also start the sum with a value other than zero:

            // >>> np.sum([10], initial=5)
            // 15
            // 

#if TODO
             given=  np.sum({10}, initial=5);
             expected=
                "15";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void nanprodTest()
        {
            // >>> np.nanprod(1)
            // 1
            // >>> np.nanprod([1])
            // 1
            // >>> np.nanprod([1, np.nan])
            // 1.0
            // >>> a = np.array([[1, 2], [3, np.nan]])
            // >>> np.nanprod(a)
            // 6.0
            // >>> np.nanprod(a, axis=0)
            // array([ 3.,  2.])
            // 

#if TODO
            var given=  np.nanprod(1);
            var expected=
                "1";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanprod({1});
             expected=
                "1";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanprod({1, np.nan});
             expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
             given=  a = np.array({{1, 2}, {3, np.nan}});
             given=  np.nanprod(a);
             expected=
                "6.0";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanprod(a, axis=0);
             expected=
                "array([ 3.,  2.])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void nansumTest()
        {
            // >>> np.nansum(1)
            // 1
            // >>> np.nansum([1])
            // 1
            // >>> np.nansum([1, np.nan])
            // 1.0
            // >>> a = np.array([[1, 1], [1, np.nan]])
            // >>> np.nansum(a)
            // 3.0
            // >>> np.nansum(a, axis=0)
            // array([ 2.,  1.])
            // >>> np.nansum([1, np.nan, np.inf])
            // inf
            // >>> np.nansum([1, np.nan, np.NINF])
            // -inf
            // >>> np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present
            // nan
            // 

#if TODO
            var given=  np.nansum(1);
            var expected=
                "1";
            Assert.AreEqual(expected, given.repr);
             given=  np.nansum({1});
             expected=
                "1";
            Assert.AreEqual(expected, given.repr);
             given=  np.nansum({1, np.nan});
             expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
             given=  a = np.array({{1, 1}, {1, np.nan}});
             given=  np.nansum(a);
             expected=
                "3.0";
            Assert.AreEqual(expected, given.repr);
             given=  np.nansum(a, axis=0);
             expected=
                "array([ 2.,  1.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nansum({1, np.nan, np.inf});
             expected=
                "inf";
            Assert.AreEqual(expected, given.repr);
             given=  np.nansum({1, np.nan, np.NINF});
             expected=
                "-inf";
            Assert.AreEqual(expected, given.repr);
             given=  np.nansum({1, np.nan, np.inf, -np.inf}) # both +/- infinity present;
             expected=
                "nan";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void cumprodTest()
        {
            // >>> a = np.array([1,2,3])
            // >>> np.cumprod(a) # intermediate results 1, 1*2
            // ...               # total product 1*2*3 = 6
            // array([1, 2, 6])
            // >>> a = np.array([[1, 2, 3], [4, 5, 6]])
            // >>> np.cumprod(a, dtype=float) # specify type of output
            // array([   1.,    2.,    6.,   24.,  120.,  720.])
            // 

#if TODO
            var given=  a = np.array({1,2,3});
             given=  np.cumprod(a) # intermediate results 1, 1*2;
            var expected=
                "...               # total product 1*2*3 = 6\n" +
                "array([1, 2, 6])";
            Assert.AreEqual(expected, given.repr);
             given=  a = np.array({{1, 2, 3}, {4, 5, 6}});
             given=  np.cumprod(a, dtype=float) # specify type of output;
             expected=
                "array([   1.,    2.,    6.,   24.,  120.,  720.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // The cumulative product for each column (i.e., over the rows) of a:

            // >>> np.cumprod(a, axis=0)
            // array([[ 1,  2,  3],
            //        [ 4, 10, 18]])
            // 

#if TODO
             given=  np.cumprod(a, axis=0);
             expected=
                "array([[ 1,  2,  3],\n" +
                "       [ 4, 10, 18]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // The cumulative product for each row (i.e. over the columns) of a:

            // >>> np.cumprod(a,axis=1)
            // array([[  1,   2,   6],
            //        [  4,  20, 120]])
            // 

#if TODO
             given=  np.cumprod(a,axis=1);
             expected=
                "array([[  1,   2,   6],\n" +
                "       [  4,  20, 120]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void cumsumTest()
        {
            // >>> a = np.array([[1,2,3], [4,5,6]])
            // >>> a
            // array([[1, 2, 3],
            //        [4, 5, 6]])
            // >>> np.cumsum(a)
            // array([ 1,  3,  6, 10, 15, 21])
            // >>> np.cumsum(a, dtype=float)     # specifies type of output value(s)
            // array([  1.,   3.,   6.,  10.,  15.,  21.])
            // 

#if TODO
            var given=  a = np.array({{1,2,3}, {4,5,6}});
             given=  a;
            var expected=
                "array([[1, 2, 3],\n" +
                "       [4, 5, 6]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.cumsum(a);
             expected=
                "array([ 1,  3,  6, 10, 15, 21])";
            Assert.AreEqual(expected, given.repr);
             given=  np.cumsum(a, dtype=float)     # specifies type of output value(s);
             expected=
                "array([  1.,   3.,   6.,  10.,  15.,  21.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns
            // array([[1, 2, 3],
            //        [5, 7, 9]])
            // >>> np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows
            // array([[ 1,  3,  6],
            //        [ 4,  9, 15]])
            // 

#if TODO
             given=  np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns;
             expected=
                "array([[1, 2, 3],\n" +
                "       [5, 7, 9]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows;
             expected=
                "array([[ 1,  3,  6],\n" +
                "       [ 4,  9, 15]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void nancumprodTest()
        {
            // >>> np.nancumprod(1)
            // array([1])
            // >>> np.nancumprod([1])
            // array([1])
            // >>> np.nancumprod([1, np.nan])
            // array([ 1.,  1.])
            // >>> a = np.array([[1, 2], [3, np.nan]])
            // >>> np.nancumprod(a)
            // array([ 1.,  2.,  6.,  6.])
            // >>> np.nancumprod(a, axis=0)
            // array([[ 1.,  2.],
            //        [ 3.,  2.]])
            // >>> np.nancumprod(a, axis=1)
            // array([[ 1.,  2.],
            //        [ 3.,  3.]])
            // 

#if TODO
            var given=  np.nancumprod(1);
            var expected=
                "array([1])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nancumprod({1});
             expected=
                "array([1])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nancumprod({1, np.nan});
             expected=
                "array([ 1.,  1.])";
            Assert.AreEqual(expected, given.repr);
             given=  a = np.array({{1, 2}, {3, np.nan}});
             given=  np.nancumprod(a);
             expected=
                "array([ 1.,  2.,  6.,  6.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nancumprod(a, axis=0);
             expected=
                "array([[ 1.,  2.],\n" +
                "       [ 3.,  2.]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nancumprod(a, axis=1);
             expected=
                "array([[ 1.,  2.],\n" +
                "       [ 3.,  3.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void nancumsumTest()
        {
            // >>> np.nancumsum(1)
            // array([1])
            // >>> np.nancumsum([1])
            // array([1])
            // >>> np.nancumsum([1, np.nan])
            // array([ 1.,  1.])
            // >>> a = np.array([[1, 2], [3, np.nan]])
            // >>> np.nancumsum(a)
            // array([ 1.,  3.,  6.,  6.])
            // >>> np.nancumsum(a, axis=0)
            // array([[ 1.,  2.],
            //        [ 4.,  2.]])
            // >>> np.nancumsum(a, axis=1)
            // array([[ 1.,  3.],
            //        [ 3.,  3.]])
            // 

#if TODO
            var given=  np.nancumsum(1);
            var expected=
                "array([1])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nancumsum({1});
             expected=
                "array([1])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nancumsum({1, np.nan});
             expected=
                "array([ 1.,  1.])";
            Assert.AreEqual(expected, given.repr);
             given=  a = np.array({{1, 2}, {3, np.nan}});
             given=  np.nancumsum(a);
             expected=
                "array([ 1.,  3.,  6.,  6.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nancumsum(a, axis=0);
             expected=
                "array([[ 1.,  2.],\n" +
                "       [ 4.,  2.]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nancumsum(a, axis=1);
             expected=
                "array([[ 1.,  3.],\n" +
                "       [ 3.,  3.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void diffTest()
        {
            // >>> x = np.array([1, 2, 4, 7, 0])
            // >>> np.diff(x)
            // array([ 1,  2,  3, -7])
            // >>> np.diff(x, n=2)
            // array([  1,   1, -10])
            // 

#if TODO
            var given=  x = np.array({1, 2, 4, 7, 0});
             given=  np.diff(x);
            var expected=
                "array([ 1,  2,  3, -7])";
            Assert.AreEqual(expected, given.repr);
             given=  np.diff(x, n=2);
             expected=
                "array([  1,   1, -10])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])
            // >>> np.diff(x)
            // array([[2, 3, 4],
            //        [5, 1, 2]])
            // >>> np.diff(x, axis=0)
            // array([[-1,  2,  0, -2]])
            // 

#if TODO
             given=  x = np.array({{1, 3, 6, 10}, {0, 5, 6, 8}});
             given=  np.diff(x);
             expected=
                "array([[2, 3, 4],\n" +
                "       [5, 1, 2]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.diff(x, axis=0);
             expected=
                "array([[-1,  2,  0, -2]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)
            // >>> np.diff(x)
            // array([1, 1], dtype='timedelta64[D]')
            // 

#if TODO
             given=  x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64);
             given=  np.diff(x);
             expected=
                "array([1, 1], dtype='timedelta64[D]')";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void ediff1dTest()
        {
            // >>> x = np.array([1, 2, 4, 7, 0])
            // >>> np.ediff1d(x)
            // array([ 1,  2,  3, -7])
            // 

#if TODO
            var given=  x = np.array({1, 2, 4, 7, 0});
             given=  np.ediff1d(x);
            var expected=
                "array([ 1,  2,  3, -7])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))
            // array([-99,   1,   2,   3,  -7,  88,  99])
            // 

#if TODO
             given=  np.ediff1d(x, to_begin=-99, to_end=np.array({88, 99}));
             expected=
                "array([-99,   1,   2,   3,  -7,  88,  99])";
            Assert.AreEqual(expected, given.repr);
#endif
            // The returned array is always 1D.

            // >>> y = [[1, 2, 4], [1, 6, 24]]
            // >>> np.ediff1d(y)
            // array([ 1,  2, -3,  5, 18])
            // 

#if TODO
             given=  y = [[1, 2, 4], [1, 6, 24]];
             given=  np.ediff1d(y);
             expected=
                "array([ 1,  2, -3,  5, 18])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void gradientTest()
        {
            // >>> f = np.array([1, 2, 4, 7, 11, 16], dtype=float)
            // >>> np.gradient(f)
            // array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])
            // >>> np.gradient(f, 2)
            // array([ 0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])
            // 

#if TODO
            var given=  f = np.array({1, 2, 4, 7, 11, 16}, dtype=float);
             given=  np.gradient(f);
            var expected=
                "array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])";
            Assert.AreEqual(expected, given.repr);
             given=  np.gradient(f, 2);
             expected=
                "array([ 0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Spacing can be also specified with an array that represents the coordinates
            // of the values F along the dimensions.
            // For instance a uniform spacing:

            // >>> x = np.arange(f.size)
            // >>> np.gradient(f, x)
            // array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])
            // 

#if TODO
             given=  x = np.arange(f.size);
             given=  np.gradient(f, x);
             expected=
                "array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Or a non uniform one:

            // >>> x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float)
            // >>> np.gradient(f, x)
            // array([ 1. ,  3. ,  3.5,  6.7,  6.9,  2.5])
            // 

#if TODO
             given=  x = np.array({0., 1., 1.5, 3.5, 4., 6.}, dtype=float);
             given=  np.gradient(f, x);
             expected=
                "array([ 1. ,  3. ,  3.5,  6.7,  6.9,  2.5])";
            Assert.AreEqual(expected, given.repr);
#endif
            // For two dimensional arrays, the return will be two arrays ordered by
            // axis. In this example the first array stands for the gradient in
            // rows and the second one in columns direction:

            // >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float))
            // [array([[ 2.,  2., -1.],
            //         [ 2.,  2., -1.]]), array([[ 1. ,  2.5,  4. ],
            //         [ 1. ,  1. ,  1. ]])]
            // 

#if TODO
             given=  np.gradient(np.array({{1, 2, 6}, {3, 4, 5}}, dtype=float));
             expected=
                "[array([[ 2.,  2., -1.],\n" +
                "        [ 2.,  2., -1.]]), array([[ 1. ,  2.5,  4. ],\n" +
                "        [ 1. ,  1. ,  1. ]])]";
            Assert.AreEqual(expected, given.repr);
#endif
            // In this example the spacing is also specified:
            // uniform for axis=0 and non uniform for axis=1

            // >>> dx = 2.
            // >>> y = [1., 1.5, 3.5]
            // >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), dx, y)
            // [array([[ 1. ,  1. , -0.5],
            //         [ 1. ,  1. , -0.5]]), array([[ 2. ,  2. ,  2. ],
            //         [ 2. ,  1.7,  0.5]])]
            // 

#if TODO
             given=  dx = 2.;
             given=  y = [1., 1.5, 3.5];
             given=  np.gradient(np.array({{1, 2, 6}, {3, 4, 5}}, dtype=float), dx, y);
             expected=
                "[array([[ 1. ,  1. , -0.5],\n" +
                "        [ 1. ,  1. , -0.5]]), array([[ 2. ,  2. ,  2. ],\n" +
                "        [ 2. ,  1.7,  0.5]])]";
            Assert.AreEqual(expected, given.repr);
#endif
            // It is possible to specify how boundaries are treated using edge_order

            // >>> x = np.array([0, 1, 2, 3, 4])
            // >>> f = x**2
            // >>> np.gradient(f, edge_order=1)
            // array([ 1.,  2.,  4.,  6.,  7.])
            // >>> np.gradient(f, edge_order=2)
            // array([-0.,  2.,  4.,  6.,  8.])
            // 

#if TODO
             given=  x = np.array({0, 1, 2, 3, 4});
             given=  f = x**2;
             given=  np.gradient(f, edge_order=1);
             expected=
                "array([ 1.,  2.,  4.,  6.,  7.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.gradient(f, edge_order=2);
             expected=
                "array([-0.,  2.,  4.,  6.,  8.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // The axis keyword can be used to specify a subset of axes of which the
            // gradient is calculated

            // >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), axis=0)
            // array([[ 2.,  2., -1.],
            //        [ 2.,  2., -1.]])
            // 

#if TODO
             given=  np.gradient(np.array({{1, 2, 6}, {3, 4, 5}}, dtype=float), axis=0);
             expected=
                "array([[ 2.,  2., -1.],\n" +
                "       [ 2.,  2., -1.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void crossTest()
        {
            // Vector cross-product.

            // >>> x = [1, 2, 3]
            // >>> y = [4, 5, 6]
            // >>> np.cross(x, y)
            // array([-3,  6, -3])
            // 

#if TODO
            var given=  x = [1, 2, 3];
             given=  y = [4, 5, 6];
             given=  np.cross(x, y);
            var expected=
                "array([-3,  6, -3])";
            Assert.AreEqual(expected, given.repr);
#endif
            // One vector with dimension 2.

            // >>> x = [1, 2]
            // >>> y = [4, 5, 6]
            // >>> np.cross(x, y)
            // array([12, -6, -3])
            // 

#if TODO
             given=  x = [1, 2];
             given=  y = [4, 5, 6];
             given=  np.cross(x, y);
             expected=
                "array([12, -6, -3])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Equivalently:

            // >>> x = [1, 2, 0]
            // >>> y = [4, 5, 6]
            // >>> np.cross(x, y)
            // array([12, -6, -3])
            // 

#if TODO
             given=  x = [1, 2, 0];
             given=  y = [4, 5, 6];
             given=  np.cross(x, y);
             expected=
                "array([12, -6, -3])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Both vectors with dimension 2.

            // >>> x = [1,2]
            // >>> y = [4,5]
            // >>> np.cross(x, y)
            // -3
            // 

#if TODO
             given=  x = [1,2];
             given=  y = [4,5];
             given=  np.cross(x, y);
             expected=
                "-3";
            Assert.AreEqual(expected, given.repr);
#endif
            // Multiple vector cross-products. Note that the direction of the cross
            // product vector is defined by the right-hand rule.

            // >>> x = np.array([[1,2,3], [4,5,6]])
            // >>> y = np.array([[4,5,6], [1,2,3]])
            // >>> np.cross(x, y)
            // array([[-3,  6, -3],
            //        [ 3, -6,  3]])
            // 

#if TODO
             given=  x = np.array({{1,2,3}, {4,5,6}});
             given=  y = np.array({{4,5,6}, {1,2,3}});
             given=  np.cross(x, y);
             expected=
                "array([[-3,  6, -3],\n" +
                "       [ 3, -6,  3]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // The orientation of c can be changed using the axisc keyword.

            // >>> np.cross(x, y, axisc=0)
            // array([[-3,  3],
            //        [ 6, -6],
            //        [-3,  3]])
            // 

#if TODO
             given=  np.cross(x, y, axisc=0);
             expected=
                "array([[-3,  3],\n" +
                "       [ 6, -6],\n" +
                "       [-3,  3]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Change the vector definition of x and y using axisa and axisb.

            // >>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])
            // >>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])
            // >>> np.cross(x, y)
            // array([[ -6,  12,  -6],
            //        [  0,   0,   0],
            //        [  6, -12,   6]])
            // >>> np.cross(x, y, axisa=0, axisb=0)
            // array([[-24,  48, -24],
            //        [-30,  60, -30],
            //        [-36,  72, -36]])
            // 

#if TODO
             given=  x = np.array({{1,2,3}, {4,5,6}, {7, 8, 9}});
             given=  y = np.array({{7, 8, 9}, {4,5,6}, {1,2,3}});
             given=  np.cross(x, y);
             expected=
                "array([[ -6,  12,  -6],\n" +
                "       [  0,   0,   0],\n" +
                "       [  6, -12,   6]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.cross(x, y, axisa=0, axisb=0);
             expected=
                "array([[-24,  48, -24],\n" +
                "       [-30,  60, -30],\n" +
                "       [-36,  72, -36]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void trapzTest()
        {
            // >>> np.trapz([1,2,3])
            // 4.0
            // >>> np.trapz([1,2,3], x=[4,6,8])
            // 8.0
            // >>> np.trapz([1,2,3], dx=2)
            // 8.0
            // >>> a = np.arange(6).reshape(2, 3)
            // >>> a
            // array([[0, 1, 2],
            //        [3, 4, 5]])
            // >>> np.trapz(a, axis=0)
            // array([ 1.5,  2.5,  3.5])
            // >>> np.trapz(a, axis=1)
            // array([ 2.,  8.])
            // 

#if TODO
            var given=  np.trapz({1,2,3});
            var expected=
                "4.0";
            Assert.AreEqual(expected, given.repr);
             given=  np.trapz({1,2,3}, x={4,6,8});
             expected=
                "8.0";
            Assert.AreEqual(expected, given.repr);
             given=  np.trapz({1,2,3}, dx=2);
             expected=
                "8.0";
            Assert.AreEqual(expected, given.repr);
             given=  a = np.arange(6).reshape(2, 3);
             given=  a;
             expected=
                "array([[0, 1, 2],\n" +
                "       [3, 4, 5]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.trapz(a, axis=0);
             expected=
                "array([ 1.5,  2.5,  3.5])";
            Assert.AreEqual(expected, given.repr);
             given=  np.trapz(a, axis=1);
             expected=
                "array([ 2.,  8.])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void expTest()
        {
            // Plot the magnitude and phase of exp(x) in the complex plane:

            // >>> import matplotlib.pyplot as plt
            // 

#if TODO
            var given=  import matplotlib.pyplot as plt;
#endif
            // >>> x = np.linspace(-2*np.pi, 2*np.pi, 100)
            // >>> xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane
            // >>> out = np.exp(xx)
            // 

#if TODO
             given=  x = np.linspace(-2*np.pi, 2*np.pi, 100);
             given=  xx = x + 1j * x{:, np.newaxis} # a + ib over complex plane;
             given=  out = np.exp(xx);
#endif
            // >>> plt.subplot(121)
            // >>> plt.imshow(np.abs(out),
            // ...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='gray')
            // >>> plt.title('Magnitude of exp(x)')
            // 

#if TODO
             given=  plt.subplot(121);
             given=  plt.imshow(np.abs(out),;
            var expected=
                "...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='gray')";
            Assert.AreEqual(expected, given.repr);
             given=  plt.title('Magnitude of exp(x)');
#endif
            // >>> plt.subplot(122)
            // >>> plt.imshow(np.angle(out),
            // ...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='hsv')
            // >>> plt.title('Phase (angle) of exp(x)')
            // >>> plt.show()
            // 

#if TODO
             given=  plt.subplot(122);
             given=  plt.imshow(np.angle(out),;
             expected=
                "...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='hsv')";
            Assert.AreEqual(expected, given.repr);
             given=  plt.title('Phase (angle) of exp(x)');
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void expm1Test()
        {
            // The true value of exp(1e-10) - 1 is 1.00000000005e-10 to
            // about 32 significant digits. This example shows the superiority of
            // expm1 in this case.

            // >>> np.expm1(1e-10)
            // 1.00000000005e-10
            // >>> np.exp(1e-10) - 1
            // 1.000000082740371e-10
            // 

#if TODO
            var given=  np.expm1(1e-10);
            var expected=
                "1.00000000005e-10";
            Assert.AreEqual(expected, given.repr);
             given=  np.exp(1e-10) - 1;
             expected=
                "1.000000082740371e-10";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void exp2Test()
        {
            // >>> np.exp2([2, 3])
            // array([ 4.,  8.])
            // 

#if TODO
            var given=  np.exp2({2, 3});
            var expected=
                "array([ 4.,  8.])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void logTest()
        {
            // >>> np.log([1, np.e, np.e**2, 0])
            // array([  0.,   1.,   2., -Inf])
            // 

#if TODO
            var given=  np.log({1, np.e, np.e**2, 0});
            var expected=
                "array([  0.,   1.,   2., -Inf])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void log10Test()
        {
            // >>> np.log10([1e-15, -3.])
            // array([-15.,  NaN])
            // 

#if TODO
            var given=  np.log10({1e-15, -3.});
            var expected=
                "array([-15.,  NaN])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void log2Test()
        {
            // >>> x = np.array([0, 1, 2, 2**4])
            // >>> np.log2(x)
            // array([-Inf,   0.,   1.,   4.])
            // 

#if TODO
            var given=  x = np.array({0, 1, 2, 2**4});
             given=  np.log2(x);
            var expected=
                "array([-Inf,   0.,   1.,   4.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> xi = np.array([0+1.j, 1, 2+0.j, 4.j])
            // >>> np.log2(xi)
            // array([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])
            // 

#if TODO
             given=  xi = np.array({0+1.j, 1, 2+0.j, 4.j});
             given=  np.log2(xi);
             expected=
                "array([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void log1pTest()
        {
            // >>> np.log1p(1e-99)
            // 1e-99
            // >>> np.log(1 + 1e-99)
            // 0.0
            // 

#if TODO
            var given=  np.log1p(1e-99);
            var expected=
                "1e-99";
            Assert.AreEqual(expected, given.repr);
             given=  np.log(1 + 1e-99);
             expected=
                "0.0";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void logaddexpTest()
        {
            // >>> prob1 = np.log(1e-50)
            // >>> prob2 = np.log(2.5e-50)
            // >>> prob12 = np.logaddexp(prob1, prob2)
            // >>> prob12
            // -113.87649168120691
            // >>> np.exp(prob12)
            // 3.5000000000000057e-50
            // 

#if TODO
            var given=  prob1 = np.log(1e-50);
             given=  prob2 = np.log(2.5e-50);
             given=  prob12 = np.logaddexp(prob1, prob2);
             given=  prob12;
            var expected=
                "-113.87649168120691";
            Assert.AreEqual(expected, given.repr);
             given=  np.exp(prob12);
             expected=
                "3.5000000000000057e-50";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void logaddexp2Test()
        {
            // >>> prob1 = np.log2(1e-50)
            // >>> prob2 = np.log2(2.5e-50)
            // >>> prob12 = np.logaddexp2(prob1, prob2)
            // >>> prob1, prob2, prob12
            // (-166.09640474436813, -164.77447664948076, -164.28904982231052)
            // >>> 2**prob12
            // 3.4999999999999914e-50
            // 

#if TODO
            var given=  prob1 = np.log2(1e-50);
             given=  prob2 = np.log2(2.5e-50);
             given=  prob12 = np.logaddexp2(prob1, prob2);
             given=  prob1, prob2, prob12;
            var expected=
                "(-166.09640474436813, -164.77447664948076, -164.28904982231052)";
            Assert.AreEqual(expected, given.repr);
             given=  2**prob12;
             expected=
                "3.4999999999999914e-50";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void sincTest()
        {
            // >>> import matplotlib.pyplot as plt
            // >>> x = np.linspace(-4, 4, 41)
            // >>> np.sinc(x)
            // array([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,
            //         -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,
            //          6.68206631e-02,   1.16434881e-01,   1.26137788e-01,
            //          8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,
            //         -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,
            //          3.89804309e-17,   2.33872321e-01,   5.04551152e-01,
            //          7.56826729e-01,   9.35489284e-01,   1.00000000e+00,
            //          9.35489284e-01,   7.56826729e-01,   5.04551152e-01,
            //          2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,
            //         -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,
            //         -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,
            //          1.16434881e-01,   6.68206631e-02,   3.89804309e-17,
            //         -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,
            //         -4.92362781e-02,  -3.89804309e-17])
            // 

#if TODO
            var given=  import matplotlib.pyplot as plt;
             given=  x = np.linspace(-4, 4, 41);
             given=  np.sinc(x);
            var expected=
                "array([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,\n" +
                "        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,\n" +
                "         6.68206631e-02,   1.16434881e-01,   1.26137788e-01,\n" +
                "         8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,\n" +
                "        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,\n" +
                "         3.89804309e-17,   2.33872321e-01,   5.04551152e-01,\n" +
                "         7.56826729e-01,   9.35489284e-01,   1.00000000e+00,\n" +
                "         9.35489284e-01,   7.56826729e-01,   5.04551152e-01,\n" +
                "         2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,\n" +
                "        -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,\n" +
                "        -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,\n" +
                "         1.16434881e-01,   6.68206631e-02,   3.89804309e-17,\n" +
                "        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,\n" +
                "        -4.92362781e-02,  -3.89804309e-17])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> plt.plot(x, np.sinc(x))
            // [<matplotlib.lines.Line2D object at 0x...>]
            // >>> plt.title("Sinc Function")
            // <matplotlib.text.Text object at 0x...>
            // >>> plt.ylabel("Amplitude")
            // <matplotlib.text.Text object at 0x...>
            // >>> plt.xlabel("X")
            // <matplotlib.text.Text object at 0x...>
            // >>> plt.show()
            // 

#if TODO
             given=  plt.plot(x, np.sinc(x));
             expected=
                "[<matplotlib.lines.Line2D object at 0x...>]";
            Assert.AreEqual(expected, given.repr);
             given=  plt.title("Sinc Function");
             expected=
                "<matplotlib.text.Text object at 0x...>";
            Assert.AreEqual(expected, given.repr);
             given=  plt.ylabel("Amplitude");
             expected=
                "<matplotlib.text.Text object at 0x...>";
            Assert.AreEqual(expected, given.repr);
             given=  plt.xlabel("X");
             expected=
                "<matplotlib.text.Text object at 0x...>";
            Assert.AreEqual(expected, given.repr);
             given=  plt.show();
#endif
            // It works in 2-D as well:

            // >>> x = np.linspace(-4, 4, 401)
            // >>> xx = np.outer(x, x)
            // >>> plt.imshow(np.sinc(xx))
            // <matplotlib.image.AxesImage object at 0x...>
            // 

#if TODO
             given=  x = np.linspace(-4, 4, 401);
             given=  xx = np.outer(x, x);
             given=  plt.imshow(np.sinc(xx));
             expected=
                "<matplotlib.image.AxesImage object at 0x...>";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void signbitTest()
        {
            // >>> np.signbit(-1.2)
            // True
            // >>> np.signbit(np.array([1, -2.3, 2.1]))
            // array([False,  True, False])
            // 

#if TODO
            var given=  np.signbit(-1.2);
            var expected=
                "True";
            Assert.AreEqual(expected, given.repr);
             given=  np.signbit(np.array({1, -2.3, 2.1}));
             expected=
                "array([False,  True, False])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void copysignTest()
        {
            // >>> np.copysign(1.3, -1)
            // -1.3
            // >>> 1/np.copysign(0, 1)
            // inf
            // >>> 1/np.copysign(0, -1)
            // -inf
            // 

#if TODO
            var given=  np.copysign(1.3, -1);
            var expected=
                "-1.3";
            Assert.AreEqual(expected, given.repr);
             given=  1/np.copysign(0, 1);
             expected=
                "inf";
            Assert.AreEqual(expected, given.repr);
             given=  1/np.copysign(0, -1);
             expected=
                "-inf";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.copysign([-1, 0, 1], -1.1)
            // array([-1., -0., -1.])
            // >>> np.copysign([-1, 0, 1], np.arange(3)-1)
            // array([-1.,  0.,  1.])
            // 

#if TODO
             given=  np.copysign({-1, 0, 1}, -1.1);
             expected=
                "array([-1., -0., -1.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.copysign({-1, 0, 1}, np.arange(3)-1);
             expected=
                "array([-1.,  0.,  1.])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void frexpTest()
        {
            // >>> x = np.arange(9)
            // >>> y1, y2 = np.frexp(x)
            // >>> y1
            // array([ 0.   ,  0.5  ,  0.5  ,  0.75 ,  0.5  ,  0.625,  0.75 ,  0.875,
            //         0.5  ])
            // >>> y2
            // array([0, 1, 2, 2, 3, 3, 3, 3, 4])
            // >>> y1 * 2**y2
            // array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])
            // 

#if TODO
            var given=  x = np.arange(9);
             given=  y1, y2 = np.frexp(x);
             given=  y1;
            var expected=
                "array([ 0.   ,  0.5  ,  0.5  ,  0.75 ,  0.5  ,  0.625,  0.75 ,  0.875,\n" +
                "        0.5  ])";
            Assert.AreEqual(expected, given.repr);
             given=  y2;
             expected=
                "array([0, 1, 2, 2, 3, 3, 3, 3, 4])";
            Assert.AreEqual(expected, given.repr);
             given=  y1 * 2**y2;
             expected=
                "array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void ldexpTest()
        {
            // >>> np.ldexp(5, np.arange(4))
            // array([  5.,  10.,  20.,  40.], dtype=float32)
            // 

#if TODO
            var given=  np.ldexp(5, np.arange(4));
            var expected=
                "array([  5.,  10.,  20.,  40.], dtype=float32)";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> x = np.arange(6)
            // >>> np.ldexp(*np.frexp(x))
            // array([ 0.,  1.,  2.,  3.,  4.,  5.])
            // 

#if TODO
             given=  x = np.arange(6);
             given=  np.ldexp(*np.frexp(x));
             expected=
                "array([ 0.,  1.,  2.,  3.,  4.,  5.])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void nextafterTest()
        {
            // >>> eps = np.finfo(np.float64).eps
            // >>> np.nextafter(1, 2) == eps + 1
            // True
            // >>> np.nextafter([1, 2], [2, 1]) == [eps + 1, 2 - eps]
            // array([ True,  True])
            // 

#if TODO
            var given=  eps = np.finfo(np.float64).eps;
             given=  np.nextafter(1, 2) == eps + 1;
            var expected=
                "True";
            Assert.AreEqual(expected, given.repr);
             given=  np.nextafter({1, 2}, {2, 1}) == {eps + 1, 2 - eps};
             expected=
                "array([ True,  True])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void spacingTest()
        {
            // >>> np.spacing(1) == np.finfo(np.float64).eps
            // True
            // 

#if TODO
            var given=  np.spacing(1) == np.finfo(np.float64).eps;
            var expected=
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void lcmTest()
        {
            // >>> np.lcm(12, 20)
            // 60
            // >>> np.lcm.reduce([3, 12, 20])
            // 60
            // >>> np.lcm.reduce([40, 12, 20])
            // 120
            // >>> np.lcm(np.arange(6), 20)
            // array([ 0, 20, 20, 60, 20, 20])
            // 

#if TODO
            var given=  np.lcm(12, 20);
            var expected=
                "60";
            Assert.AreEqual(expected, given.repr);
             given=  np.lcm.reduce({3, 12, 20});
             expected=
                "60";
            Assert.AreEqual(expected, given.repr);
             given=  np.lcm.reduce({40, 12, 20});
             expected=
                "120";
            Assert.AreEqual(expected, given.repr);
             given=  np.lcm(np.arange(6), 20);
             expected=
                "array([ 0, 20, 20, 60, 20, 20])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void gcdTest()
        {
            // >>> np.gcd(12, 20)
            // 4
            // >>> np.gcd.reduce([15, 25, 35])
            // 5
            // >>> np.gcd(np.arange(6), 20)
            // array([20,  1,  2,  1,  4,  5])
            // 

#if TODO
            var given=  np.gcd(12, 20);
            var expected=
                "4";
            Assert.AreEqual(expected, given.repr);
             given=  np.gcd.reduce({15, 25, 35});
             expected=
                "5";
            Assert.AreEqual(expected, given.repr);
             given=  np.gcd(np.arange(6), 20);
             expected=
                "array([20,  1,  2,  1,  4,  5])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void addTest()
        {
            // >>> np.add(1.0, 4.0)
            // 5.0
            // >>> x1 = np.arange(9.0).reshape((3, 3))
            // >>> x2 = np.arange(3.0)
            // >>> np.add(x1, x2)
            // array([[  0.,   2.,   4.],
            //        [  3.,   5.,   7.],
            //        [  6.,   8.,  10.]])
            // 

#if TODO
            var given=  np.add(1.0, 4.0);
            var expected=
                "5.0";
            Assert.AreEqual(expected, given.repr);
             given=  x1 = np.arange(9.0).reshape((3, 3));
             given=  x2 = np.arange(3.0);
             given=  np.add(x1, x2);
             expected=
                "array([[  0.,   2.,   4.],\n" +
                "       [  3.,   5.,   7.],\n" +
                "       [  6.,   8.,  10.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void reciprocalTest()
        {
            // >>> np.reciprocal(2.)
            // 0.5
            // >>> np.reciprocal([1, 2., 3.33])
            // array([ 1.       ,  0.5      ,  0.3003003])
            // 

#if TODO
            var given=  np.reciprocal(2.);
            var expected=
                "0.5";
            Assert.AreEqual(expected, given.repr);
             given=  np.reciprocal({1, 2., 3.33});
             expected=
                "array([ 1.       ,  0.5      ,  0.3003003])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void negativeTest()
        {
            // >>> np.negative([1.,-1.])
            // array([-1.,  1.])
            // 

#if TODO
            var given=  np.negative({1.,-1.});
            var expected=
                "array([-1.,  1.])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void multiplyTest()
        {
            // >>> np.multiply(2.0, 4.0)
            // 8.0
            // 

#if TODO
            var given=  np.multiply(2.0, 4.0);
            var expected=
                "8.0";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> x1 = np.arange(9.0).reshape((3, 3))
            // >>> x2 = np.arange(3.0)
            // >>> np.multiply(x1, x2)
            // array([[  0.,   1.,   4.],
            //        [  0.,   4.,  10.],
            //        [  0.,   7.,  16.]])
            // 

#if TODO
             given=  x1 = np.arange(9.0).reshape((3, 3));
             given=  x2 = np.arange(3.0);
             given=  np.multiply(x1, x2);
             expected=
                "array([[  0.,   1.,   4.],\n" +
                "       [  0.,   4.,  10.],\n" +
                "       [  0.,   7.,  16.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void divideTest()
        {
            // >>> x = np.arange(5)
            // >>> np.true_divide(x, 4)
            // array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
            // 

#if TODO
            var given=  x = np.arange(5);
             given=  np.true_divide(x, 4);
            var expected=
                "array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> x/4
            // array([0, 0, 0, 0, 1])
            // >>> x//4
            // array([0, 0, 0, 0, 1])
            // 

#if TODO
             given=  x/4;
             expected=
                "array([0, 0, 0, 0, 1])";
            Assert.AreEqual(expected, given.repr);
             given=  x//4;
             expected=
                "array([0, 0, 0, 0, 1])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> from __future__ import division
            // >>> x/4
            // array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
            // >>> x//4
            // array([0, 0, 0, 0, 1])
            // 

#if TODO
             given=  from __future__ import division;
             given=  x/4;
             expected=
                "array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])";
            Assert.AreEqual(expected, given.repr);
             given=  x//4;
             expected=
                "array([0, 0, 0, 0, 1])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void powerTest()
        {
            // Cube each element in a list.

            // >>> x1 = range(6)
            // >>> x1
            // [0, 1, 2, 3, 4, 5]
            // >>> np.power(x1, 3)
            // array([  0,   1,   8,  27,  64, 125])
            // 

#if TODO
            var given=  x1 = range(6);
             given=  x1;
            var expected=
                "[0, 1, 2, 3, 4, 5]";
            Assert.AreEqual(expected, given.repr);
             given=  np.power(x1, 3);
             expected=
                "array([  0,   1,   8,  27,  64, 125])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Raise the bases to different exponents.

            // >>> x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]
            // >>> np.power(x1, x2)
            // array([  0.,   1.,   8.,  27.,  16.,   5.])
            // 

#if TODO
             given=  x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0];
             given=  np.power(x1, x2);
             expected=
                "array([  0.,   1.,   8.,  27.,  16.,   5.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // The effect of broadcasting.

            // >>> x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])
            // >>> x2
            // array([[1, 2, 3, 3, 2, 1],
            //        [1, 2, 3, 3, 2, 1]])
            // >>> np.power(x1, x2)
            // array([[ 0,  1,  8, 27, 16,  5],
            //        [ 0,  1,  8, 27, 16,  5]])
            // 

#if TODO
             given=  x2 = np.array({{1, 2, 3, 3, 2, 1}, {1, 2, 3, 3, 2, 1}});
             given=  x2;
             expected=
                "array([[1, 2, 3, 3, 2, 1],\n" +
                "       [1, 2, 3, 3, 2, 1]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.power(x1, x2);
             expected=
                "array([[ 0,  1,  8, 27, 16,  5],\n" +
                "       [ 0,  1,  8, 27, 16,  5]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void subtractTest()
        {
            // >>> np.subtract(1.0, 4.0)
            // -3.0
            // 

#if TODO
            var given=  np.subtract(1.0, 4.0);
            var expected=
                "-3.0";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> x1 = np.arange(9.0).reshape((3, 3))
            // >>> x2 = np.arange(3.0)
            // >>> np.subtract(x1, x2)
            // array([[ 0.,  0.,  0.],
            //        [ 3.,  3.,  3.],
            //        [ 6.,  6.,  6.]])
            // 

#if TODO
             given=  x1 = np.arange(9.0).reshape((3, 3));
             given=  x2 = np.arange(3.0);
             given=  np.subtract(x1, x2);
             expected=
                "array([[ 0.,  0.,  0.],\n" +
                "       [ 3.,  3.,  3.],\n" +
                "       [ 6.,  6.,  6.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void true_divideTest()
        {
            // >>> x = np.arange(5)
            // >>> np.true_divide(x, 4)
            // array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
            // 

#if TODO
            var given=  x = np.arange(5);
             given=  np.true_divide(x, 4);
            var expected=
                "array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> x/4
            // array([0, 0, 0, 0, 1])
            // >>> x//4
            // array([0, 0, 0, 0, 1])
            // 

#if TODO
             given=  x/4;
             expected=
                "array([0, 0, 0, 0, 1])";
            Assert.AreEqual(expected, given.repr);
             given=  x//4;
             expected=
                "array([0, 0, 0, 0, 1])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> from __future__ import division
            // >>> x/4
            // array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
            // >>> x//4
            // array([0, 0, 0, 0, 1])
            // 

#if TODO
             given=  from __future__ import division;
             given=  x/4;
             expected=
                "array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])";
            Assert.AreEqual(expected, given.repr);
             given=  x//4;
             expected=
                "array([0, 0, 0, 0, 1])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void floor_divideTest()
        {
            // >>> np.floor_divide(7,3)
            // 2
            // >>> np.floor_divide([1., 2., 3., 4.], 2.5)
            // array([ 0.,  0.,  1.,  1.])
            // 

#if TODO
            var given=  np.floor_divide(7,3);
            var expected=
                "2";
            Assert.AreEqual(expected, given.repr);
             given=  np.floor_divide({1., 2., 3., 4.}, 2.5);
             expected=
                "array([ 0.,  0.,  1.,  1.])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void float_powerTest()
        {
            // Cube each element in a list.

            // >>> x1 = range(6)
            // >>> x1
            // [0, 1, 2, 3, 4, 5]
            // >>> np.float_power(x1, 3)
            // array([   0.,    1.,    8.,   27.,   64.,  125.])
            // 

#if TODO
            var given=  x1 = range(6);
             given=  x1;
            var expected=
                "[0, 1, 2, 3, 4, 5]";
            Assert.AreEqual(expected, given.repr);
             given=  np.float_power(x1, 3);
             expected=
                "array([   0.,    1.,    8.,   27.,   64.,  125.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Raise the bases to different exponents.

            // >>> x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]
            // >>> np.float_power(x1, x2)
            // array([  0.,   1.,   8.,  27.,  16.,   5.])
            // 

#if TODO
             given=  x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0];
             given=  np.float_power(x1, x2);
             expected=
                "array([  0.,   1.,   8.,  27.,  16.,   5.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // The effect of broadcasting.

            // >>> x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])
            // >>> x2
            // array([[1, 2, 3, 3, 2, 1],
            //        [1, 2, 3, 3, 2, 1]])
            // >>> np.float_power(x1, x2)
            // array([[  0.,   1.,   8.,  27.,  16.,   5.],
            //        [  0.,   1.,   8.,  27.,  16.,   5.]])
            // 

#if TODO
             given=  x2 = np.array({{1, 2, 3, 3, 2, 1}, {1, 2, 3, 3, 2, 1}});
             given=  x2;
             expected=
                "array([[1, 2, 3, 3, 2, 1],\n" +
                "       [1, 2, 3, 3, 2, 1]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.float_power(x1, x2);
             expected=
                "array([[  0.,   1.,   8.,  27.,  16.,   5.],\n" +
                "       [  0.,   1.,   8.,  27.,  16.,   5.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void fmodTest()
        {
            // >>> np.fmod([-3, -2, -1, 1, 2, 3], 2)
            // array([-1,  0, -1,  1,  0,  1])
            // >>> np.remainder([-3, -2, -1, 1, 2, 3], 2)
            // array([1, 0, 1, 1, 0, 1])
            // 

#if TODO
            var given=  np.fmod({-3, -2, -1, 1, 2, 3}, 2);
            var expected=
                "array([-1,  0, -1,  1,  0,  1])";
            Assert.AreEqual(expected, given.repr);
             given=  np.remainder({-3, -2, -1, 1, 2, 3}, 2);
             expected=
                "array([1, 0, 1, 1, 0, 1])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.fmod([5, 3], [2, 2.])
            // array([ 1.,  1.])
            // >>> a = np.arange(-3, 3).reshape(3, 2)
            // >>> a
            // array([[-3, -2],
            //        [-1,  0],
            //        [ 1,  2]])
            // >>> np.fmod(a, [2,2])
            // array([[-1,  0],
            //        [-1,  0],
            //        [ 1,  0]])
            // 

#if TODO
             given=  np.fmod({5, 3}, {2, 2.});
             expected=
                "array([ 1.,  1.])";
            Assert.AreEqual(expected, given.repr);
             given=  a = np.arange(-3, 3).reshape(3, 2);
             given=  a;
             expected=
                "array([[-3, -2],\n" +
                "       [-1,  0],\n" +
                "       [ 1,  2]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.fmod(a, {2,2});
             expected=
                "array([[-1,  0],\n" +
                "       [-1,  0],\n" +
                "       [ 1,  0]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void modTest()
        {
            // >>> np.remainder([4, 7], [2, 3])
            // array([0, 1])
            // >>> np.remainder(np.arange(7), 5)
            // array([0, 1, 2, 3, 4, 0, 1])
            // 

#if TODO
            var given=  np.remainder({4, 7}, {2, 3});
            var expected=
                "array([0, 1])";
            Assert.AreEqual(expected, given.repr);
             given=  np.remainder(np.arange(7), 5);
             expected=
                "array([0, 1, 2, 3, 4, 0, 1])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void modfTest()
        {
            // >>> np.modf([0, 3.5])
            // (array([ 0. ,  0.5]), array([ 0.,  3.]))
            // >>> np.modf(-0.5)
            // (-0.5, -0)
            // 

#if TODO
            var given=  np.modf({0, 3.5});
            var expected=
                "(array([ 0. ,  0.5]), array([ 0.,  3.]))";
            Assert.AreEqual(expected, given.repr);
             given=  np.modf(-0.5);
             expected=
                "(-0.5, -0)";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void remainderTest()
        {
            // >>> np.remainder([4, 7], [2, 3])
            // array([0, 1])
            // >>> np.remainder(np.arange(7), 5)
            // array([0, 1, 2, 3, 4, 0, 1])
            // 

#if TODO
            var given=  np.remainder({4, 7}, {2, 3});
            var expected=
                "array([0, 1])";
            Assert.AreEqual(expected, given.repr);
             given=  np.remainder(np.arange(7), 5);
             expected=
                "array([0, 1, 2, 3, 4, 0, 1])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void divmodTest()
        {
            // >>> np.divmod(np.arange(5), 3)
            // (array([0, 0, 0, 1, 1]), array([0, 1, 2, 0, 1]))
            // 

#if TODO
            var given=  np.divmod(np.arange(5), 3);
            var expected=
                "(array([0, 0, 0, 1, 1]), array([0, 1, 2, 0, 1]))";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void angleTest()
        {
            // >>> np.angle([1.0, 1.0j, 1+1j])               # in radians
            // array([ 0.        ,  1.57079633,  0.78539816])
            // >>> np.angle(1+1j, deg=True)                  # in degrees
            // 45.0
            // 

#if TODO
            var given=  np.angle({1.0, 1.0j, 1+1j})               # in radians;
            var expected=
                "array([ 0.        ,  1.57079633,  0.78539816])";
            Assert.AreEqual(expected, given.repr);
             given=  np.angle(1+1j, deg=True)                  # in degrees;
             expected=
                "45.0";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void realTest()
        {
            // >>> a = np.array([1+2j, 3+4j, 5+6j])
            // >>> a.real
            // array([ 1.,  3.,  5.])
            // >>> a.real = 9
            // >>> a
            // array([ 9.+2.j,  9.+4.j,  9.+6.j])
            // >>> a.real = np.array([9, 8, 7])
            // >>> a
            // array([ 9.+2.j,  8.+4.j,  7.+6.j])
            // >>> np.real(1 + 1j)
            // 1.0
            // 

#if TODO
            var given=  a = np.array({1+2j, 3+4j, 5+6j});
             given=  a.real;
            var expected=
                "array([ 1.,  3.,  5.])";
            Assert.AreEqual(expected, given.repr);
             given=  a.real = 9;
             given=  a;
             expected=
                "array([ 9.+2.j,  9.+4.j,  9.+6.j])";
            Assert.AreEqual(expected, given.repr);
             given=  a.real = np.array({9, 8, 7});
             given=  a;
             expected=
                "array([ 9.+2.j,  8.+4.j,  7.+6.j])";
            Assert.AreEqual(expected, given.repr);
             given=  np.real(1 + 1j);
             expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void imagTest()
        {
            // >>> a = np.array([1+2j, 3+4j, 5+6j])
            // >>> a.imag
            // array([ 2.,  4.,  6.])
            // >>> a.imag = np.array([8, 10, 12])
            // >>> a
            // array([ 1. +8.j,  3.+10.j,  5.+12.j])
            // >>> np.imag(1 + 1j)
            // 1.0
            // 

#if TODO
            var given=  a = np.array({1+2j, 3+4j, 5+6j});
             given=  a.imag;
            var expected=
                "array([ 2.,  4.,  6.])";
            Assert.AreEqual(expected, given.repr);
             given=  a.imag = np.array({8, 10, 12});
             given=  a;
             expected=
                "array([ 1. +8.j,  3.+10.j,  5.+12.j])";
            Assert.AreEqual(expected, given.repr);
             given=  np.imag(1 + 1j);
             expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void conjTest()
        {
            // >>> np.conjugate(1+2j)
            // (1-2j)
            // 

#if TODO
            var given=  np.conjugate(1+2j);
            var expected=
                "(1-2j)";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> x = np.eye(2) + 1j * np.eye(2)
            // >>> np.conjugate(x)
            // array([[ 1.-1.j,  0.-0.j],
            //        [ 0.-0.j,  1.-1.j]])
            // 

#if TODO
             given=  x = np.eye(2) + 1j * np.eye(2);
             given=  np.conjugate(x);
             expected=
                "array([[ 1.-1.j,  0.-0.j],\n" +
                "       [ 0.-0.j,  1.-1.j]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void convolveTest()
        {
            // Note how the convolution operator flips the second array
            // before “sliding” the two across one another:

            // >>> np.convolve([1, 2, 3], [0, 1, 0.5])
            // array([ 0. ,  1. ,  2.5,  4. ,  1.5])
            // 

#if TODO
            var given=  np.convolve({1, 2, 3}, {0, 1, 0.5});
            var expected=
                "array([ 0. ,  1. ,  2.5,  4. ,  1.5])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Only return the middle values of the convolution.
            // Contains boundary effects, where zeros are taken
            // into account:

            // >>> np.convolve([1,2,3],[0,1,0.5], 'same')
            // array([ 1. ,  2.5,  4. ])
            // 

#if TODO
             given=  np.convolve({1,2,3},{0,1,0.5}, 'same');
             expected=
                "array([ 1. ,  2.5,  4. ])";
            Assert.AreEqual(expected, given.repr);
#endif
            // The two arrays are of the same length, so there
            // is only one position where they completely overlap:

            // >>> np.convolve([1,2,3],[0,1,0.5], 'valid')
            // array([ 2.5])
            // 

#if TODO
             given=  np.convolve({1,2,3},{0,1,0.5}, 'valid');
             expected=
                "array([ 2.5])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void clipTest()
        {
            // >>> a = np.arange(10)
            // >>> np.clip(a, 1, 8)
            // array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])
            // >>> a
            // array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
            // >>> np.clip(a, 3, 6, out=a)
            // array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
            // >>> a = np.arange(10)
            // >>> a
            // array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
            // >>> np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)
            // array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])
            // 

#if TODO
            var given=  a = np.arange(10);
             given=  np.clip(a, 1, 8);
            var expected=
                "array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])";
            Assert.AreEqual(expected, given.repr);
             given=  a;
             expected=
                "array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])";
            Assert.AreEqual(expected, given.repr);
             given=  np.clip(a, 3, 6, out=a);
             expected=
                "array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])";
            Assert.AreEqual(expected, given.repr);
             given=  a = np.arange(10);
             given=  a;
             expected=
                "array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])";
            Assert.AreEqual(expected, given.repr);
             given=  np.clip(a, {3, 4, 1, 1, 1, 4, 4, 4, 4, 4}, 8);
             expected=
                "array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void sqrtTest()
        {
            // >>> np.sqrt([1,4,9])
            // array([ 1.,  2.,  3.])
            // 

#if TODO
            var given=  np.sqrt({1,4,9});
            var expected=
                "array([ 1.,  2.,  3.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.sqrt([4, -1, -3+4J])
            // array([ 2.+0.j,  0.+1.j,  1.+2.j])
            // 

#if TODO
             given=  np.sqrt({4, -1, -3+4J});
             expected=
                "array([ 2.+0.j,  0.+1.j,  1.+2.j])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.sqrt([4, -1, numpy.inf])
            // array([  2.,  NaN,  Inf])
            // 

#if TODO
             given=  np.sqrt({4, -1, numpy.inf});
             expected=
                "array([  2.,  NaN,  Inf])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void cbrtTest()
        {
            // >>> np.cbrt([1,8,27])
            // array([ 1.,  2.,  3.])
            // 

#if TODO
            var given=  np.cbrt({1,8,27});
            var expected=
                "array([ 1.,  2.,  3.])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void squareTest()
        {
            // >>> np.square([-1j, 1])
            // array([-1.-0.j,  1.+0.j])
            // 

#if TODO
            var given=  np.square({-1j, 1});
            var expected=
                "array([-1.-0.j,  1.+0.j])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void absoluteTest()
        {
            // >>> x = np.array([-1.2, 1.2])
            // >>> np.absolute(x)
            // array([ 1.2,  1.2])
            // >>> np.absolute(1.2 + 1j)
            // 1.5620499351813308
            // 

#if TODO
            var given=  x = np.array({-1.2, 1.2});
             given=  np.absolute(x);
            var expected=
                "array([ 1.2,  1.2])";
            Assert.AreEqual(expected, given.repr);
             given=  np.absolute(1.2 + 1j);
             expected=
                "1.5620499351813308";
            Assert.AreEqual(expected, given.repr);
#endif
            // Plot the function over [-10, 10]:

            // >>> import matplotlib.pyplot as plt
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
#endif
            // >>> x = np.linspace(start=-10, stop=10, num=101)
            // >>> plt.plot(x, np.absolute(x))
            // >>> plt.show()
            // 

#if TODO
             given=  x = np.linspace(start=-10, stop=10, num=101);
             given=  plt.plot(x, np.absolute(x));
             given=  plt.show();
#endif
            // Plot the function over the complex plane:

            // >>> xx = x + 1j * x[:, np.newaxis]
            // >>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')
            // >>> plt.show()
            // 

#if TODO
             given=  xx = x + 1j * x{:, np.newaxis};
             given=  plt.imshow(np.abs(xx), extent={-10, 10, -10, 10}, cmap='gray');
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void fabsTest()
        {
            // >>> np.fabs(-1)
            // 1.0
            // >>> np.fabs([-1.2, 1.2])
            // array([ 1.2,  1.2])
            // 

#if TODO
            var given=  np.fabs(-1);
            var expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
             given=  np.fabs({-1.2, 1.2});
             expected=
                "array([ 1.2,  1.2])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void signTest()
        {
            // >>> np.sign([-5., 4.5])
            // array([-1.,  1.])
            // >>> np.sign(0)
            // 0
            // >>> np.sign(5-2j)
            // (1+0j)
            // 

#if TODO
            var given=  np.sign({-5., 4.5});
            var expected=
                "array([-1.,  1.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.sign(0);
             expected=
                "0";
            Assert.AreEqual(expected, given.repr);
             given=  np.sign(5-2j);
             expected=
                "(1+0j)";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void heavisideTest()
        {
            // >>> np.heaviside([-1.5, 0, 2.0], 0.5)
            // array([ 0. ,  0.5,  1. ])
            // >>> np.heaviside([-1.5, 0, 2.0], 1)
            // array([ 0.,  1.,  1.])
            // 

#if TODO
            var given=  np.heaviside({-1.5, 0, 2.0}, 0.5);
            var expected=
                "array([ 0. ,  0.5,  1. ])";
            Assert.AreEqual(expected, given.repr);
             given=  np.heaviside({-1.5, 0, 2.0}, 1);
             expected=
                "array([ 0.,  1.,  1.])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void maximumTest()
        {
            // >>> np.maximum([2, 3, 4], [1, 5, 2])
            // array([2, 5, 4])
            // 

#if TODO
            var given=  np.maximum({2, 3, 4}, {1, 5, 2});
            var expected=
                "array([2, 5, 4])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting
            // array([[ 1. ,  2. ],
            //        [ 0.5,  2. ]])
            // 

#if TODO
             given=  np.maximum(np.eye(2), {0.5, 2}) # broadcasting;
             expected=
                "array([[ 1. ,  2. ],\n" +
                "       [ 0.5,  2. ]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan])
            // array([ NaN,  NaN,  NaN])
            // >>> np.maximum(np.Inf, 1)
            // inf
            // 

#if TODO
             given=  np.maximum({np.nan, 0, np.nan}, {0, np.nan, np.nan});
             expected=
                "array([ NaN,  NaN,  NaN])";
            Assert.AreEqual(expected, given.repr);
             given=  np.maximum(np.Inf, 1);
             expected=
                "inf";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void minimumTest()
        {
            // >>> np.minimum([2, 3, 4], [1, 5, 2])
            // array([1, 3, 2])
            // 

#if TODO
            var given=  np.minimum({2, 3, 4}, {1, 5, 2});
            var expected=
                "array([1, 3, 2])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.minimum(np.eye(2), [0.5, 2]) # broadcasting
            // array([[ 0.5,  0. ],
            //        [ 0. ,  1. ]])
            // 

#if TODO
             given=  np.minimum(np.eye(2), {0.5, 2}) # broadcasting;
             expected=
                "array([[ 0.5,  0. ],\n" +
                "       [ 0. ,  1. ]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan])
            // array([ NaN,  NaN,  NaN])
            // >>> np.minimum(-np.Inf, 1)
            // -inf
            // 

#if TODO
             given=  np.minimum({np.nan, 0, np.nan},{0, np.nan, np.nan});
             expected=
                "array([ NaN,  NaN,  NaN])";
            Assert.AreEqual(expected, given.repr);
             given=  np.minimum(-np.Inf, 1);
             expected=
                "-inf";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void fmaxTest()
        {
            // >>> np.fmax([2, 3, 4], [1, 5, 2])
            // array([ 2.,  5.,  4.])
            // 

#if TODO
            var given=  np.fmax({2, 3, 4}, {1, 5, 2});
            var expected=
                "array([ 2.,  5.,  4.])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.fmax(np.eye(2), [0.5, 2])
            // array([[ 1. ,  2. ],
            //        [ 0.5,  2. ]])
            // 

#if TODO
             given=  np.fmax(np.eye(2), {0.5, 2});
             expected=
                "array([[ 1. ,  2. ],\n" +
                "       [ 0.5,  2. ]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.fmax([np.nan, 0, np.nan],[0, np.nan, np.nan])
            // array([  0.,   0.,  NaN])
            // 

#if TODO
             given=  np.fmax({np.nan, 0, np.nan},{0, np.nan, np.nan});
             expected=
                "array([  0.,   0.,  NaN])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void fminTest()
        {
            // >>> np.fmin([2, 3, 4], [1, 5, 2])
            // array([1, 3, 2])
            // 

#if TODO
            var given=  np.fmin({2, 3, 4}, {1, 5, 2});
            var expected=
                "array([1, 3, 2])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.fmin(np.eye(2), [0.5, 2])
            // array([[ 0.5,  0. ],
            //        [ 0. ,  1. ]])
            // 

#if TODO
             given=  np.fmin(np.eye(2), {0.5, 2});
             expected=
                "array([[ 0.5,  0. ],\n" +
                "       [ 0. ,  1. ]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.fmin([np.nan, 0, np.nan],[0, np.nan, np.nan])
            // array([  0.,   0.,  NaN])
            // 

#if TODO
             given=  np.fmin({np.nan, 0, np.nan},{0, np.nan, np.nan});
             expected=
                "array([  0.,   0.,  NaN])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void nan_to_numTest()
        {
            // >>> np.nan_to_num(np.inf)
            // 1.7976931348623157e+308
            // >>> np.nan_to_num(-np.inf)
            // -1.7976931348623157e+308
            // >>> np.nan_to_num(np.nan)
            // 0.0
            // >>> x = np.array([np.inf, -np.inf, np.nan, -128, 128])
            // >>> np.nan_to_num(x)
            // array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,
            //         -1.28000000e+002,   1.28000000e+002])
            // >>> y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)])
            // >>> np.nan_to_num(y)
            // array([  1.79769313e+308 +0.00000000e+000j,
            //          0.00000000e+000 +0.00000000e+000j,
            //          0.00000000e+000 +1.79769313e+308j])
            // 

#if TODO
            var given=  np.nan_to_num(np.inf);
            var expected=
                "1.7976931348623157e+308";
            Assert.AreEqual(expected, given.repr);
             given=  np.nan_to_num(-np.inf);
             expected=
                "-1.7976931348623157e+308";
            Assert.AreEqual(expected, given.repr);
             given=  np.nan_to_num(np.nan);
             expected=
                "0.0";
            Assert.AreEqual(expected, given.repr);
             given=  x = np.array({np.inf, -np.inf, np.nan, -128, 128});
             given=  np.nan_to_num(x);
             expected=
                "array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,\n" +
                "        -1.28000000e+002,   1.28000000e+002])";
            Assert.AreEqual(expected, given.repr);
             given=  y = np.array({complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)});
             given=  np.nan_to_num(y);
             expected=
                "array([  1.79769313e+308 +0.00000000e+000j,\n" +
                "         0.00000000e+000 +0.00000000e+000j,\n" +
                "         0.00000000e+000 +1.79769313e+308j])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void real_if_closeTest()
        {
            // >>> np.finfo(float).eps
            // 2.2204460492503131e-16
            // 

#if TODO
            var given=  np.finfo(float).eps;
            var expected=
                "2.2204460492503131e-16";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.real_if_close([2.1 + 4e-14j], tol=1000)
            // array([ 2.1])
            // >>> np.real_if_close([2.1 + 4e-13j], tol=1000)
            // array([ 2.1 +4.00000000e-13j])
            // 

#if TODO
             given=  np.real_if_close({2.1 + 4e-14j}, tol=1000);
             expected=
                "array([ 2.1])";
            Assert.AreEqual(expected, given.repr);
             given=  np.real_if_close({2.1 + 4e-13j}, tol=1000);
             expected=
                "array([ 2.1 +4.00000000e-13j])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void interpTest()
        {
            // >>> xp = [1, 2, 3]
            // >>> fp = [3, 2, 0]
            // >>> np.interp(2.5, xp, fp)
            // 1.0
            // >>> np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)
            // array([ 3. ,  3. ,  2.5 ,  0.56,  0. ])
            // >>> UNDEF = -99.0
            // >>> np.interp(3.14, xp, fp, right=UNDEF)
            // -99.0
            // 

            var xp = new float[] { 1, 2, 3 };
            var fp = new float[] { 3, 2, 0 };
            Assert.AreEqual(1.0f, np.interp(2.5f, xp, fp));

            var given = np.interp(new float[] { 0, 1, 1.5f, 2.72f, 3.14f }, xp, fp);
            var expected =
                "array([3.        , 3.        , 2.5       , 0.55999994, 0.        ])";
            Assert.AreEqual(expected, given.repr);

            var UNDEF = -99.0f;
            Assert.AreEqual(-99.0f, np.interp(3.14f, xp, fp, right: UNDEF));

            // Interpolation with periodic x-coordinates:

            // >>> x = [-180, -170, -185, 185, -10, -5, 0, 365]
            // >>> xp = [190, -190, 350, -350]
            // >>> fp = [5, 10, 3, 4]
            // >>> np.interp(x, xp, fp, period=360)
            // array([7.5, 5., 8.75, 6.25, 3., 3.25, 3.5, 3.75])
            // 

            //var  x = [-180, -170, -185, 185, -10, -5, 0, 365];
            var x = new float[] { -180, -170, -185, 185, -10, -5, 0, 365 };
            xp = new float[] { 190, -190, 350, -350 };
            fp = new float[] { 5, 10, 3, 4 };
            given = np.interp(x, xp, fp, period: 360);
            expected =
               "array([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])";
            Assert.AreEqual(expected, given.repr);

            // Complex interpolation:

            // >>> x = [1.5, 4.0]
            // >>> xp = [2,3,5]
            // >>> fp = [1.0j, 0, 2+3j]
            // >>> np.interp(x, xp, fp)
            // array([ 0.+1.j ,  1.+1.5j])

            x = new float[] { 1.5f, 4.0f };
            xp = new float[] { 2, 3, 5 };
            var fp2 = new [] { new Complex(0, 1), new Complex(0, 0), new Complex(2, 3) };
            given = np.interp(x, xp, fp2);
            expected =
               "array([0.+1.j , 1.+1.5j])";
            Assert.AreEqual(expected, given.repr);
        }

    }
}
